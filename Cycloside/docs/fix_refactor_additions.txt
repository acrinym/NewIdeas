Fixes, refactorings, and additions. 

--- FILE: D:\github\newideas\Cycloside\App.axaml ---<Application xmlns="https://github.com/avaloniaui"xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"x:Class="Cycloside.App"RequestedThemeVariant="Default"><!-- "Default" ThemeVariant follows system theme variant. "Dark" or "Light" are other available options. --><Application.Styles>
    <FluentTheme />
</Application.Styles>

<!--
  REFACTOR: This is the central resource dictionary for the application.
  It's empty by default.
  Your 'ThemeManager' or 'SkinManager' (in C#) will be responsible for loading 
  the selected skin file (e.g., Mint.axaml) and merging its resources here at runtime.
  This allows resources like 'ApplicationBackgroundBrush' to be found by any window.
-->
<Application.Resources>
    <ResourceDictionary>
        <!-- This will be populated by your ThemeManager -->
    </ResourceDictionary>
</Application.Resources>
</Application>--- FILE: D:\github\newideas\Cycloside\App.axaml.cs ---using Avalonia;using Avalonia.Controls.ApplicationLifetimes;using Avalonia.Input;using Avalonia.Markup.Xaml;using Avalonia.Platform.Storage;using Cycloside.Plugins;using Cycloside.Plugins.BuiltIn;using Cycloside.ViewModels;using Cycloside.Services;using Cycloside.Views;using System;using System.Collections.Generic;using System.Diagnostics;using System.Drawing;using System.IO;using System.Linq;using System.Runtime.InteropServices;using System.Runtime.Versioning;using System.Threading.Tasks;namespace Cycloside;public partial class App : Application{private const string TrayIconBase64 = "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAGElEQVR4nGNkaGAgCTCRpnxUw6iGoaQBALsfAKDg6Y6zAAAAAElFTkSuQmCC";private RemoteApiServer? _remoteServer;private PluginManager? _pluginManager;public override void Initialize()
{
    AvaloniaXamlLoader.Load(this);
}

public override void OnFrameworkInitializationCompleted()
{
    if (ApplicationLifetime is not IClassicDesktopStyleApplicationLifetime desktop)
    {
        base.OnFrameworkInitializationCompleted();
        return;
    }

    var settings = SettingsManager.Settings;

    ThemeManager.LoadGlobalThemeFromSettings();

    if (settings.FirstRun)
    {
        var wiz = new WizardWindow();
        wiz.Closed += (_, _) =>
        {
            desktop.MainWindow = CreateMainWindow(SettingsManager.Settings);
            desktop.MainWindow.Show();
        };
        wiz.Show();
    }
    else
    {
        desktop.MainWindow = CreateMainWindow(settings);
        desktop.MainWindow.Show();
    }

    base.OnFrameworkInitializationCompleted();
}

private MainWindow CreateMainWindow(AppSettings settings)
{
    _pluginManager = new PluginManager(Path.Combine(AppContext.BaseDirectory, "Plugins"), msg => Logger.Log(msg));
    var volatileManager = new VolatilePluginManager();
    
    LoadAllPlugins(_pluginManager, settings);
    _pluginManager.StartWatching();
    
    var viewModel = new MainWindowViewModel(_pluginManager.Plugins);
    var mainWindow = new MainWindow
    {
        DataContext = viewModel
    };
    
    viewModel.ExitCommand = new RelayCommand(() => Shutdown(_pluginManager));
    viewModel.StartPluginCommand = new RelayCommand(plugin => {
        if(plugin is IPlugin p) _pluginManager.EnablePlugin(p);
    });

    _remoteServer = new RemoteApiServer(_pluginManager, settings.RemoteApiToken);
    _remoteServer.Start();
    WorkspaceProfiles.Apply(settings.ActiveProfile, _pluginManager);
    RegisterHotkeys(_pluginManager);
    
    var trayIcon = new TrayIcon
    {
        Icon = CreateTrayIcon(),
        ToolTipText = "Cycloside",
        Menu = BuildTrayMenu(_pluginManager, volatileManager, settings)
    };
    
    var icons = TrayIcon.GetIcons(this) ?? new TrayIcons();
    TrayIcon.SetIcons(this, icons);
    if (!icons.Contains(trayIcon))
    {
        icons.Add(trayIcon);
    }
    trayIcon.IsVisible = true;
    
    return mainWindow;
}

private void LoadAllPlugins(PluginManager manager, AppSettings settings)
{
    if (settings.DisableBuiltInPlugins) return;

    manager.AddPlugin(new DateTimeOverlayPlugin());
    manager.AddPlugin(new MP3PlayerPlugin());
    manager.AddPlugin(new MacroPlugin());
    manager.AddPlugin(new TextEditorPlugin());
    manager.AddPlugin(new WallpaperPlugin());
    manager.AddPlugin(new ClipboardManagerPlugin());
    manager.AddPlugin(new FileWatcherPlugin());
    manager.AddPlugin(new ProcessMonitorPlugin());
    manager.AddPlugin(new TaskSchedulerPlugin());
    manager.AddPlugin(new DiskUsagePlugin());
    manager.AddPlugin(new TerminalPlugin());
    manager.AddPlugin(new LogViewerPlugin());
    manager.AddPlugin(new EnvironmentEditorPlugin());
    manager.AddPlugin(new JezzballPlugin());
    manager.AddPlugin(new WidgetHostPlugin(manager));
    manager.AddPlugin(new WinampVisHostPlugin());
    manager.AddPlugin(new QBasicRetroIDEPlugin());
}

private void RegisterHotkeys(PluginManager manager)
{
    HotkeyManager.Register(new KeyGesture(Key.W, KeyModifiers.Control | KeyModifiers.Alt), () =>
    {
        var plugin = manager.Plugins.FirstOrDefault(p => p.Name == "Widget Host");
        if (plugin != null)
        {
            if (manager.IsEnabled(plugin)) manager.DisablePlugin(plugin);
            else manager.EnablePlugin(plugin);
        }
    });
}

private void Shutdown(PluginManager manager)
{
    manager.StopAll();
    _remoteServer?.Stop();
    HotkeyManager.UnregisterAll();
    // NEW: Gracefully shut down the logger to ensure all messages are written to disk.
    Logger.Shutdown();
    if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime appLifetime)
    {
        appLifetime.Shutdown();
    }
}

#region Tray Menu and Icon Logic

private NativeMenu BuildTrayMenu(PluginManager manager, VolatilePluginManager volatileManager, AppSettings settings)
{
    var pluginsMenu = new NativeMenuItem("Plugins") { Menu = new NativeMenu() };
    var newPlugins = manager.Plugins.Where(p => manager.GetStatus(p) != PluginChangeStatus.None).ToList();
    var otherPlugins = manager.Plugins.Except(newPlugins).OrderBy(p => p.Name).ToList();

    if (newPlugins.Any())
    {
        var newMenu = new NativeMenuItem("New/Updated") { Menu = new NativeMenu() };
        foreach (var p in newPlugins) newMenu.Menu!.Items.Add(BuildPluginMenuItem(p, manager, settings));
        pluginsMenu.Menu!.Items.Add(newMenu);
        pluginsMenu.Menu!.Items.Add(new NativeMenuItemSeparator());
    }

    foreach (var p in otherPlugins) pluginsMenu.Menu!.Items.Add(BuildPluginMenuItem(p, manager, settings));

    var volatileMenu = new NativeMenuItem("Volatile") { Menu = new NativeMenu() };
    volatileMenu.Menu!.Items.Add(BuildVolatileScriptMenuItem("Run Lua Script...", new FilePickerFileType("Lua Script") { Patterns = new[] { "*.lua" } }, volatileManager.RunLua));
    volatileMenu.Menu!.Items.Add(BuildVolatileScriptMenuItem("Run C# Script...", new FilePickerFileType("C# Script") { Patterns = new[] { "*.csx" } }, volatileManager.RunCSharp));
    volatileMenu.Menu!.Items.Add(new NativeMenuItemSeparator());
    var inlineItem = new NativeMenuItem("Run Inline...");
    inlineItem.Click += (_, _) => new VolatileRunnerWindow(volatileManager).Show();
    volatileMenu.Menu!.Items.Add(inlineItem);

    return new NativeMenu
    {
        Items =
        {
            new NativeMenuItem("Settings") { Menu = new NativeMenu { Items = {
                new NativeMenuItem("Plugin Manager...") { Command = new RelayCommand(() => new PluginSettingsWindow(manager).Show()) },
                new NativeMenuItem("Generate New Plugin...") { Command = new RelayCommand(() => new PluginDevWizard().Show()) },
                new NativeMenuItem("Theme Settings...") { Command = new RelayCommand(() => new ThemeSettingsWindow(manager).Show()) },
                new NativeMenuItem("Skin/Theme Editor...") { Command = new RelayCommand(() => new SkinThemeEditorWindow().Show()) },
                new NativeMenuItem("Workspace Profiles...") { Command = new RelayCommand(() => new ProfileEditorWindow(manager).Show()) },
                new NativeMenuItem("Runtime Settings...") { Command = new RelayCommand(() => new RuntimeSettingsWindow(manager).Show()) }
            }}},
            new NativeMenuItemSeparator(),
            new NativeMenuItem("Launch at Startup") { IsChecked = settings.LaunchAtStartup, ToggleType = NativeMenuItemToggleType.CheckBox, Command = new RelayCommand(o => {
                if (o is not NativeMenuItem item) return;
                settings.LaunchAtStartup = !settings.LaunchAtStartup;
                if (settings.LaunchAtStartup) StartupManager.Enable(); else StartupManager.Disable();
                SettingsManager.Save();
                item.IsChecked = settings.LaunchAtStartup;
            })},
            new NativeMenuItemSeparator(),
            pluginsMenu,
            volatileMenu,
            new NativeMenuItem("Open Plugins Folder") { Command = new RelayCommand(() => {
                try { Process.Start(new ProcessStartInfo { FileName = manager.PluginDirectory, UseShellExecute = true }); } 
                catch (Exception ex) { Logger.Log($"Failed to open plugin folder: {ex.Message}"); }
            })},
            new NativeMenuItemSeparator(),
            new NativeMenuItem("Exit") { Command = new RelayCommand(() => Shutdown(manager)) }
        }
    };
}

private NativeMenuItem BuildPluginMenuItem(IPlugin plugin, PluginManager manager, AppSettings settings)
{
    var status = manager.GetStatus(plugin);
    string label = plugin.Name + status switch
    {
        PluginChangeStatus.New => " (NEW)",
        PluginChangeStatus.Updated => " (UPDATED)",
        _ => ""
    };

    var menuItem = new NativeMenuItem(label)
    {
        ToggleType = NativeMenuItemToggleType.CheckBox,
        IsChecked = settings.PluginEnabled.TryGetValue(plugin.Name, out var isEnabled) ? isEnabled : true
    };

    if (menuItem.IsChecked && !manager.IsEnabled(plugin)) manager.EnablePlugin(plugin);
    else if (!menuItem.IsChecked && manager.IsEnabled(plugin)) manager.DisablePlugin(plugin);

    menuItem.Command = new RelayCommand(o =>
    {
        if (o is not NativeMenuItem item) return;
        if (manager.IsEnabled(plugin))
            manager.DisablePlugin(plugin);
        else
            manager.EnablePlugin(plugin);

        item.IsChecked = manager.IsEnabled(plugin);
        settings.PluginEnabled[plugin.Name] = item.IsChecked;
        SettingsManager.Save();
    });
    menuItem.CommandParameter = menuItem;

    return menuItem;
}

private NativeMenuItem BuildVolatileScriptMenuItem(string title, FilePickerFileType filter, Action<string> scriptRunner)
{
    var menuItem = new NativeMenuItem(title);
    menuItem.Click += async (_, _) =>
    {
        if (Application.Current?.ApplicationLifetime is not IClassicDesktopStyleApplicationLifetime desktop || desktop.MainWindow is null) return;

        var files = await desktop.MainWindow.StorageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            AllowMultiple = false,
            FileTypeFilter = new[] { filter }
        });

        if (files.FirstOrDefault() is { } file)
        {
            try
            {
                await using var stream = await file.OpenReadAsync();
                using var reader = new StreamReader(stream);
                var code = await reader.ReadToEndAsync();
                scriptRunner(code);
            }
            catch (Exception ex) { Logger.Log($"Failed to run volatile script {file.Name}: {ex.Message}"); }
        }
    };
    return menuItem;
}

private static WindowIcon CreateTrayIcon()
{
    if (OperatingSystem.IsWindows())
    {
        try
        {
            var systemDir = Environment.GetFolderPath(Environment.SpecialFolder.System);
            var icon = ExtractIconFromDll(Path.Combine(systemDir, "imageres.dll"), 25) ??
                       ExtractIconFromDll(Path.Combine(systemDir, "shell32.dll"), 20) ??
                       ExtractIconFromDll(Path.Combine(systemDir, "shell32.dll"), 8);
            if (icon != null)
            {
                using var stream = new MemoryStream();
                #pragma warning disable CA1416
                icon.Save(stream);
                #pragma warning restore CA1416
                stream.Position = 0;
                return new WindowIcon(stream);
            }
        }
        catch (Exception ex) { Logger.Log($"Failed to extract system icon: {ex.Message}"); }
    }
    var bytes = Convert.FromBase64String(TrayIconBase64);
    return new WindowIcon(new MemoryStream(bytes));
}

[SupportedOSPlatform("windows")]
private static Icon? ExtractIconFromDll(string path, int index)
{
    IntPtr hIcon = ExtractIcon(IntPtr.Zero, path, index);
    if (hIcon == IntPtr.Zero) return null;
    try
    {
        var icon = (Icon)Icon.FromHandle(hIcon).Clone();
        return icon;
    }
    finally
    {
        DestroyIcon(hIcon);
    }
}

[DllImport("shell32.dll", CharSet = CharSet.Auto)]
private static extern IntPtr ExtractIcon(IntPtr hInst, string lpszExeFileName, int nIconIndex);

[DllImport("user32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool DestroyIcon(IntPtr handle);

#endregion
}--- FILE: D:\github\newideas\Cycloside\CursorManager.cs ---using Avalonia;using Avalonia.Input;using System;namespace Cycloside.Services; // REFACTOR: Moved to Services namespace/// <summary>/// Manages the application of custom cursors to UI elements./// </summary>public static class CursorManager{/// <summary>/// Applies a standard cursor to a UI element by its name./// </summary>/// <param name="element">The UI element to apply the cursor to.</param>/// <param name="cursorName">The name of the standard cursor (e.g., "Hand", "Arrow").</param>public static void ApplyCursor(InputElement element, string cursorName){try{if (Enum.TryParse<StandardCursorType>(cursorName, true, out var type)){element.Cursor = new Cursor(type);}else{Logger.Log("Warning: Cursor '{cursorName}' not found. Defaulting to Arrow.");element.Cursor = new Cursor(StandardCursorType.Arrow);}}catch (Exception ex){Logger.Log("Error applying cursor '{cursorName}': {ex.Message}");}}/// <summary>
/// Applies a cursor to a UI element based on the component's name from the global settings.
/// </summary>
/// <param name="element">The UI element to apply the cursor to.</param>
/// <param name="component">The name of the component to look up in settings.</param>
public static void ApplyFromSettings(InputElement element, string component)
{
    var map = SettingsManager.Settings.ComponentCursors;
    if (map != null && map.TryGetValue(component, out var cursorName) && !string.IsNullOrWhiteSpace(cursorName))
    {
        ApplyCursor(element, cursorName);
    }
}
}--- FILE: D:\github\newideas\Cycloside\GlobalUsings.cs ---// REFACTOR: This file is useful for large projects but can sometimes hide dependencies.// For clarity in this refactoring, I am removing it and adding the 'using' statements// directly to the files that need them. If you prefer the global using, you can restore this file.// In this refactored version, this file is now empty and can be deleted.--- FILE: D:\github\newideas\Cycloside\HotkeyManager.cs ---using System;using System.Collections.Generic;using Avalonia.Input;using Cycloside.Hotkeys;namespace Cycloside.Services; // REFACTOR: Moved to Services namespace/// <summary>/// REFACTOR: A more robust cross-platform global hotkey manager./// It now uses a single internal manager based on the operating system,/// simplifying the registration logic./// </summary>public static class HotkeyManager{// REFACTOR: Use a single interface for the hotkey manager.private interface IGlobalHotkeyManager : IDisposable{event Action<KeyGesture>? HotKeyPressed;void Register(KeyGesture gesture);void UnregisterAll();}private static readonly IGlobalHotkeyManager? _manager;
private static readonly Dictionary<KeyGesture, Action> _callbacks = new();

static HotkeyManager()
{
    try
    {
        if (OperatingSystem.IsWindows() || OperatingSystem.IsLinux())
        {
            _manager = new SharpGlobalHotkeyManager();
        }
        else if (OperatingSystem.IsMacOS())
        {
            _manager = new MacGlobalHotkeyManager();
        }

        if (_manager != null)
        {
            _manager.HotKeyPressed += OnHotKeyPressed;
        }
    }
    catch (Exception ex)
    {
        Logger.Log($"Failed to initialize global hotkey manager: {ex.Message}");
        _manager = null;
    }
}

private static void OnHotKeyPressed(KeyGesture gesture)
{
    if (_callbacks.TryGetValue(gesture, out var callback))
    {
        try
        {
            Avalonia.Threading.Dispatcher.UIThread.InvokeAsync(callback);
        }
        catch (Exception ex)
        {
            Logger.Log($"Error executing hotkey callback for '{gesture}': {ex.Message}");
        }
    }
}

public static void Register(KeyGesture gesture, Action callback)
{
    if (_manager == null)
    {
        Logger.Log("Hotkey manager not available on this platform or failed to initialize.");
        return;
    }
    _callbacks[gesture] = callback;
    _manager.Register(gesture);
}

public static void UnregisterAll()
{
    _manager?.UnregisterAll();
    _callbacks.Clear();
}
}--- FILE: D:\github\newideas\Cycloside\Logger.cs ---using System;using System.IO;using System.Threading.Tasks;namespace Cycloside;/// <summary>/// REFACTOR: A more robust, thread-safe, and asynchronous logger./// </summary>public static class Logger{private static readonly string LogDir = Path.Combine(AppContext.BaseDirectory, "logs");private static readonly string LogFile = Path.Combine(LogDir, "app.log");private static readonly System.Collections.Concurrent.BlockingCollection<string> _logQueue = new();private static readonly Task _logTask;static Logger()
{
    Directory.CreateDirectory(LogDir);
    _logTask = Task.Run(ProcessLogQueue);
}

/// <summary>
/// Queues a message to be written to the log file.
/// </summary>
public static void Log(string message)
{
    if (!_logQueue.IsAddingCompleted)
    {
        _logQueue.Add($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
    }
}

private static void ProcessLogQueue()
{
    foreach (var message in _logQueue.GetConsumingEnumerable())
    {
        try
        {
            File.AppendAllText(LogFile, message + Environment.NewLine);

            var fileInfo = new FileInfo(LogFile);
            if (fileInfo.Exists && fileInfo.Length > 1_048_576) // 1 MB
            {
                var backupFile = Path.Combine(LogDir, "app.log.1");
                File.Move(LogFile, backupFile, overwrite: true);
            }
        }
        catch (Exception)
        {
            // If logging fails, there's not much we can do.
        }
    }
}

/// <summary>
/// NEW: Gracefully shuts down the logger.
/// </summary>
public static void Shutdown()
{
    _logQueue.CompleteAdding();
    try
    {
        _logTask.Wait(TimeSpan.FromSeconds(2));
    }
    catch (TaskCanceledException) { /* Expected if app shuts down quickly */ }
}
}--- FILE: D:\github\newideas\Cycloside\Plugins\BuiltIn\MP3PlayerPlugin.cs ---using CommunityToolkit.Mvvm.ComponentModel;using CommunityToolkit.Mvvm.Input;using System;using System.Collections.ObjectModel;using System.IO;using System.Linq;using System.Threading.Tasks;using Avalonia;using Avalonia.Controls.ApplicationLifetimes;using Avalonia.Platform.Storage;using Avalonia.Threading;using Cycloside.Services;using NAudio.Wave;using NAudio.Dsp;namespace Cycloside.Plugins.BuiltIn{public record AudioData(byte[] Spectrum, byte[] Waveform);public class SpectrumAnalyzer
{
    private readonly ISampleProvider _source;
    private readonly Complex[] _fftBuffer;
    private readonly float[] _sampleBuffer;
    private readonly int _fftLength;

    public SpectrumAnalyzer(ISampleProvider source, int fftLength = 1024)
    {
        if (fftLength <= 0 || (fftLength & (fftLength - 1)) != 0)
            throw new ArgumentException("FFT length must be a power of 2.");

        _source = source;
        _fftLength = fftLength;
        _fftBuffer = new Complex[fftLength];
        _sampleBuffer = new float[fftLength];
    }

    public void GetFftData(byte[] fftData)
    {
        int read = _source is SampleAggregator agg
            ? agg.Read(_sampleBuffer)
            : _source.Read(_sampleBuffer, 0, _fftLength);
        if (read == 0) return;

        for (int i = 0; i < read; i++)
        {
            _fftBuffer[i].X = (float)(_sampleBuffer[i] * FftExtensions.BlackmanHarrisWindow(i, _fftLength));
            _fftBuffer[i].Y = 0;
        }
        Array.Clear(_fftBuffer, read, _fftLength - read);

        FastFourierTransform.FFT(true, (int)Math.Log(_fftLength, 2.0), _fftBuffer);

        // FIX: This calculation is simplified to provide a more direct magnitude,
        // which is what most classic visualizers (like AVS) expect.
        for (int i = 0; i < fftData.Length && i < _fftLength / 2; i++)
        {
            double magnitude = Math.Sqrt(_fftBuffer[i].X * _fftBuffer[i].X + _fftBuffer[i].Y * _fftBuffer[i].Y);
            // Scale magnitude to a byte value. The multiplier (e.g., 4.0) can be tweaked
            // to adjust the sensitivity of the visualization.
            byte scaledValue = (byte)Math.Min(255, magnitude * 255 * 4.0);
            fftData[i] = scaledValue;
        }
    }

    public void GetWaveformData(byte[] waveformData)
    {
        for (int i = 0; i < Math.Min(waveformData.Length, _sampleBuffer.Length); i++)
        {
            waveformData[i] = (byte)((_sampleBuffer[i] + 1.0) * 127.5);
        }
    }
}

public partial class MP3PlayerPlugin : ObservableObject, IPlugin, IDisposable
{
    private const string AudioDataTopic = "audio:data";
    private readonly DispatcherTimer _progressTimer;
    private int _currentIndex = -1;
    private IWavePlayer? _wavePlayer;
    private AudioFileReader? _audioReader;
    private float _volumeBeforeMute;
    private SpectrumAnalyzer? _spectrumAnalyzer;
    // NEW: Reference to the plugin's window.
    private MP3PlayerWindow? _window;

    public string Name => "MP3 Player";
    public string Description => "Play MP3 files with a simple playlist and visualization support.";
    public Version Version => new(1, 7, 0);
    public Widgets.IWidget? Widget => new Widgets.BuiltIn.Mp3Widget(this);
    public bool ForceDefaultTheme => false;

    public ObservableCollection<string> Playlist { get; } = new();
    [ObservableProperty] private string? _currentTrackName;
    [ObservableProperty] [NotifyPropertyChangedFor(nameof(IsStopped))] private bool _isPlaying;
    public bool IsStopped => !IsPlaying;
    [ObservableProperty] private TimeSpan _currentTime;
    [ObservableProperty] private TimeSpan _totalTime;
    [ObservableProperty] private string? _errorMessage;
    [ObservableProperty] [NotifyCanExecuteChangedFor(nameof(ToggleMuteCommand))] private float _volume = 1.0f;
    [ObservableProperty] private bool _isMuted;

    public MP3PlayerPlugin()
    {
        _progressTimer = new DispatcherTimer(TimeSpan.FromMilliseconds(33), DispatcherPriority.Background, OnTimerTick) { IsEnabled = false };
    }

    // FIX: The Start method now creates and shows a UI for the plugin.
    public void Start()
    {
        if (_window != null)
        {
            _window.Activate();
            return;
        }
        _window = new MP3PlayerWindow { DataContext = this };
        WindowEffectsManager.Instance.ApplyConfiguredEffects(_window, Name);
        _window.Closed += (_, _) => _window = null; // Clear reference on close
        _window.Show();
    }

    public void Stop() => Dispose();
    public void Dispose()
    {
        _progressTimer.Stop();
        CleanupPlayback();
        _window?.Close();
        GC.SuppressFinalize(this);
    }

    [RelayCommand]
    private async Task AddFiles()
    {
        var topLevel = _window ?? Application.Current?.GetMainTopLevel();
        if (topLevel is null) return;
        
        var openResult = await topLevel.StorageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = "Select MP3 Files", AllowMultiple = true,
            FileTypeFilter = new[] { new FilePickerFileType("MP3 Files") { Patterns = new[] { "*.mp3" } } }
        });
        if (openResult is null) return;

        var validFiles = openResult.Select(f => f.TryGetLocalPath()).OfType<string>();
        foreach (var file in validFiles.Where(File.Exists))
        {
            if (!Playlist.Contains(file)) Playlist.Add(file);
        }
        if (!IsPlaying && Playlist.Any())
        {
            _currentIndex = 0;
            UpdateCurrentTrackInfo();
            Play();
        }
    }

    [RelayCommand(CanExecute = nameof(CanPlay))]
    private void Play()
    {
        if (_wavePlayer is null && _currentIndex != -1)
        {
            if (!InitializeReader(Playlist[_currentIndex]))
            {
                Next();
                return;
            }
        }
        _wavePlayer?.Play();
        if (_wavePlayer != null) IsPlaying = true;
    }

    [RelayCommand(CanExecute = nameof(IsPlaying))]
    private void Pause()
    {
        _wavePlayer?.Pause();
        IsPlaying = false;
    }

    [RelayCommand(CanExecute = nameof(IsPlaying))]
    private void StopPlayback() => CleanupPlayback(); // Renamed to avoid conflict with IPlugin.Stop

    [RelayCommand(CanExecute = nameof(HasNext))]
    private void Next() => SkipToTrack(_currentIndex + 1);

    [RelayCommand(CanExecute = nameof(HasPrevious))]
    private void Previous() => SkipToTrack(_currentIndex - 1);

    [RelayCommand]
    private void Seek(TimeSpan position)
    {
        if (_audioReader is not null) _audioReader.CurrentTime = position;
    }

    [RelayCommand(CanExecute = nameof(CanMute))]
    private void ToggleMute()
    {
        _volumeBeforeMute = Volume;
        IsMuted = !IsMuted;
        Volume = IsMuted ? 0f : _volumeBeforeMute;
    }

    private bool CanPlay() => !IsPlaying && Playlist.Any();
    private bool HasNext() => _currentIndex < Playlist.Count - 1;
    private bool HasPrevious() => _currentIndex > 0;
    private bool CanMute() => _wavePlayer != null;

    private void SkipToTrack(int index)
    {
        if (index < 0 || index >= Playlist.Count) return;
        var wasPlaying = IsPlaying;
        CleanupPlayback();
        _currentIndex = index;
        UpdateCurrentTrackInfo();
        if (wasPlaying) Play();
    }

    private bool InitializeReader(string filePath)
    {
        ErrorMessage = null;
        try
        {
            _audioReader = new AudioFileReader(filePath);
            var aggregator = new SampleAggregator(_audioReader);
            _spectrumAnalyzer = new SpectrumAnalyzer(aggregator, 1024);

            _wavePlayer = new WaveOutEvent { Volume = Volume, DesiredLatency = 200 };
            _wavePlayer.Init(aggregator);
            _wavePlayer.PlaybackStopped += OnPlaybackStopped;
            TotalTime = _audioReader.TotalTime;
            CurrentTime = TimeSpan.Zero;
            return true;
        }
        catch (Exception ex)
        {
            var friendlyError = $"Failed to load: {Path.GetFileName(filePath)}";
            Logger.Log($"[ERROR] {friendlyError} | Details: {ex.Message}");
            ErrorMessage = friendlyError;
            CleanupPlayback();
            return false;
        }
    }

    private void OnPlaybackStopped(object? sender, StoppedEventArgs e)
    {
        IsPlaying = false;
        if (e.Exception is null && _audioReader is not null && _audioReader.Position >= _audioReader.Length)
        {
            Dispatcher.UIThread.InvokeAsync(() => { if (HasNext()) Next(); else CleanupPlayback(); });
        }
    }

    private void OnTimerTick(object? sender, EventArgs e)
    {
        if (_audioReader is null || !IsPlaying || _spectrumAnalyzer is null) return;
        CurrentTime = _audioReader.CurrentTime;

        // FIX: Ensure byte arrays are correctly sized for Winamp visualizers (576 samples)
        var spectrum = new byte[576];
        var waveform = new byte[576];
        
        _spectrumAnalyzer.GetFftData(spectrum);
        _spectrumAnalyzer.GetWaveformData(waveform);

        // NEW: Publish a stereo version of the data for plugins that expect it.
        var stereoSpectrum = new byte[1152];
        var stereoWaveform = new byte[1152];
        Array.Copy(spectrum, 0, stereoSpectrum, 0, 576);
        Array.Copy(spectrum, 0, stereoSpectrum, 576, 576); // Duplicate mono to right channel
        Array.Copy(waveform, 0, stereoWaveform, 0, 576);
        Array.Copy(waveform, 0, stereoWaveform, 576, 576);

        var payload = new AudioData(stereoSpectrum, stereoWaveform);
        PluginBus.Publish(AudioDataTopic, payload);
    }

    private void CleanupPlayback()
    {
        _progressTimer.Stop();
        if (_wavePlayer != null)
        {
            _wavePlayer.PlaybackStopped -= OnPlaybackStopped;
            _wavePlayer.Stop();
            _wavePlayer.Dispose();
            _wavePlayer = null;
        }
        if (_audioReader != null)
        {
            _audioReader.Dispose();
            _audioReader = null;
        }
        _spectrumAnalyzer = null;
        IsPlaying = false;
        CurrentTime = TimeSpan.Zero;
        TotalTime = TimeSpan.Zero;
    }

    private void UpdateCurrentTrackInfo()
    {
        CurrentTrackName = _currentIndex != -1 ? Path.GetFileNameWithoutExtension(Playlist[_currentIndex]) : "No track loaded";
    }

    partial void OnVolumeChanged(float value)
    {
        if (_wavePlayer != null) _wavePlayer.Volume = value;
        if (value > 0 && IsMuted) IsMuted = false;
    }

    partial void OnIsPlayingChanged(bool value)
    {
        if (value) _progressTimer.Start();
        else _progressTimer.Stop();
        
        PlayCommand.NotifyCanExecuteChanged();
        PauseCommand.NotifyCanExecuteChanged();
        StopPlaybackCommand.NotifyCanExecuteChanged();
    }
}
}--- FILE: D:\github\newideas\Cycloside\Plugins\BuiltIn\Views\MP3PlayerWindow.axaml ---<!-- NEW FILE --><Window xmlns="https://github.com/avaloniaui"xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"xmlns:local="clr-namespace:Cycloside.Plugins.BuiltIn"x:Class="Cycloside.Plugins.BuiltIn.Views.MP3PlayerWindow"x:DataType="local:MP3PlayerPlugin"Icon="/Assets/avalonia-logo.ico"Title="MP3 Player"Width="400" MinWidth="350"Height="180" MinHeight="180" SizeToContent="Height"WindowStartupLocation="CenterScreen"><Design.DataContext>
    <local:MP3PlayerPlugin/>
</Design.DataContext>

<Border Padding="10" Background="{DynamicResource ThemeBackgroundBrush}">
    <DockPanel LastChildFill="True">

        <!-- Error Message Display -->
        <TextBlock Text="{Binding ErrorMessage}"
                   Foreground="Red"
                   IsVisible="{Binding ErrorMessage, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                   DockPanel.Dock="Top"
                   Margin="0,0,0,5"
                   TextWrapping="Wrap"/>

        <!-- Track Info and Playlist -->
        <Grid DockPanel.Dock="Top" ColumnDefinitions="*,Auto">
            <TextBlock Text="{Binding CurrentTrackName}"
                       Grid.Column="0"
                       FontWeight="Bold"
                       VerticalAlignment="Center"
                       TextTrimming="CharacterEllipsis"/>
            <Button Content="Add Files..."
                    Grid.Column="1"
                    Command="{Binding AddFilesCommand}"/>
        </Grid>

        <!-- Progress Bar -->
        <DockPanel DockPanel.Dock="Top" Margin="0,8">
            <TextBlock Text="{Binding CurrentTime, StringFormat=mm\\:ss}" DockPanel.Dock="Left" VerticalAlignment="Center"/>
            <TextBlock Text="{Binding TotalTime, StringFormat=mm\\:ss}" DockPanel.Dock="Right" VerticalAlignment="Center"/>
            <Slider Value="{Binding CurrentTime.TotalSeconds}"
                    Maximum="{Binding TotalTime.TotalSeconds}"
                    PointerReleased="SeekSlider_OnPointerReleased"
                    Margin="8,0"/>
        </DockPanel>

        <!-- Main Player Controls -->
        <StackPanel Orientation="Horizontal" Spacing="5"
                    HorizontalAlignment="Center"
                    DockPanel.Dock="Top" Margin="0,5,0,10">
            <Button Content="&#x25C0;&#x25C0;" Command="{Binding PreviousCommand}"/> <!-- << -->
            <Button Content="&#x25B6;" Command="{Binding PlayCommand}"/> <!-- Play -->
            <Button Content="&#x23F8;" Command="{Binding PauseCommand}"/> <!-- Pause -->
            <Button Content="&#x25A0;" Command="{Binding StopPlaybackCommand}"/> <!-- Stop -->
            <Button Content="&#x25B6;&#x25B6;" Command="{Binding NextCommand}"/> <!-- >> -->
        </StackPanel>

        <!-- Volume Control -->
        <DockPanel DockPanel.Dock="Top">
            <Button Content="&#x1F507;" Command="{Binding ToggleMuteCommand}" DockPanel.Dock="Left"/> <!-- Mute Icon -->
            <Slider Value="{Binding Volume, Mode=TwoWay}" Minimum="0" Maximum="1.0" Margin="8,0"/>
        </DockPanel>

        <!-- Playlist -->
        <ListBox ItemsSource="{Binding Playlist}"
                 Margin="0,10,0,0"
                 ScrollViewer.VerticalScrollBarVisibility="Auto">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding ., Converter={x:Static local:FullPathToFileNameConverter.Instance}}"/>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

    </DockPanel>
</Border>
</Window>--- FILE: D:\github\newideas\Cycloside\Plugins\BuiltIn\Views\MP3PlayerWindow.axaml.cs ---<!-- NEW FILE -->using Avalonia.Controls;using Avalonia.Input;using System;using System.Globalization;using Avalonia.Data.Converters;using System.IO;namespace Cycloside.Plugins.BuiltIn.Views{public partial class MP3PlayerWindow : Window{public MP3PlayerWindow(){InitializeComponent();}    private void SeekSlider_OnPointerReleased(object? sender, PointerReleasedEventArgs e)
    {
        if (DataContext is MP3PlayerPlugin vm && sender is Slider slider)
        {
            var seekTime = TimeSpan.FromSeconds(slider.Value);
            if (vm.SeekCommand.CanExecute(seekTime))
            {
                vm.SeekCommand.Execute(seekTime);
            }
        }
    }
}

/// <summary>
/// A simple value converter to display just the file name from a full path.
/// </summary>
public class FullPathToFileNameConverter : IValueConverter
{
    public static readonly FullPathToFileNameConverter Instance = new();

    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is string fullPath && !string.IsNullOrEmpty(fullPath))
        {
            try
            {
                return Path.GetFileNameWithoutExtension(fullPath);
            }
            catch
            {
                return fullPath; // Fallback to full path on error
            }
        }
        return string.Empty;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
}--- FILE: D:\github\newideas\Cycloside\Services\RelayCommand.cs ---// NEW FILEusing System;using System.Windows.Input;namespace Cycloside.Services{/// <summary>/// A reusable command whose sole purpose is to relay its functionality/// to other objects by invoking delegates. The default return value for/// the CanExecute method is 'true'./// </summary>public class RelayCommand : ICommand{private readonly Action<object?> _execute;private readonly Predicate<object?>? _canExecute;    public event EventHandler? CanExecuteChanged
    {
        add => CommandManager.RequerySuggested += value;
        remove => CommandManager.RequerySuggested -= value;
    }

    public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }
    
    public RelayCommand(Action execute) : this(_ => execute()) {}

    public bool CanExecute(object? parameter) => _canExecute == null || _canExecute(parameter);

    public void Execute(object? parameter) => _execute(parameter);
}
}--- FILE: D:\github\newideas\Cycloside\Visuals\VisPluginManager.cs ---using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Timers;using Cycloside.Plugins.BuiltIn;namespace Cycloside.Visuals{public class VisPluginManager : IDisposable{private const string AudioDataTopic = "audio:data";    private readonly List<WinampVisPluginAdapter> _plugins = new();
    private WinampVisPluginAdapter? _active;
    private Timer? _renderTimer;
    private VisHostWindow? _window;
    private readonly Action<object?> _busHandler;

    public IReadOnlyList<WinampVisPluginAdapter> Plugins => _plugins;

    public VisPluginManager()
    {
        _busHandler = OnAudioDataReceived;
    }

    public void Load(string directory)
    {
        if (!OperatingSystem.IsWindows()) return;
        if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);
        foreach (var dll in Directory.GetFiles(directory, "vis_*.dll"))
        {
            var plugin = new WinampVisPluginAdapter(dll);
            if (plugin.Load())
            {
                _plugins.Add(plugin);
            }
        }
    }

    public bool StartFirst()
    {
        var plugin = _plugins.FirstOrDefault();
        return plugin != null && StartPlugin(plugin);
    }

    public bool StartPlugin(WinampVisPluginAdapter plugin)
    {
        if (!_plugins.Contains(plugin)) return false;
        
        // FIX: Ensure any existing window is closed before creating a new one.
        _window?.Close();
        _window = new VisHostWindow();
        _window.Closed += (_,_) => StopPlugin(); // NEW: Ensure cleanup when window is closed by user.
        _window.Show();
        
        plugin.SetParent(_window.GetHandle());

        if (!plugin.Initialize()) return false;
        _active = plugin;
        
        PluginBus.Subscribe(AudioDataTopic, _busHandler);

        _renderTimer?.Stop();
        _renderTimer = new Timer(33); // ~30 FPS
        _renderTimer.Elapsed += (_, _) => _active?.Render();
        _renderTimer.Start();
        return true;
    }
    
    // NEW: Method to properly stop the active visualization.
    private void StopPlugin()
    {
        PluginBus.Unsubscribe(AudioDataTopic, _busHandler);
        _renderTimer?.Stop();
        _active?.Quit();
        _active = null;
        _window = null;
    }

    private void OnAudioDataReceived(object? payload)
    {
        if (_active != null && payload is AudioData audioData)
        {
            // NEW: Add logging to verify data flow.
            // Logger.Log($"VisPluginManager received audio data. Spectrum[0]: {audioData.Spectrum[0]}");
            _active.UpdateAudioData(audioData);
        }
    }

    public void Dispose()
    {
        StopPlugin();
        foreach (var p in _plugins)
        {
            p.Quit();
        }
    }
}
}
